#pragma once
#include "entity.hpp"
#include <vector>
#include <unordered_set>
#include <time.h>
#include <iostream>
#include <random>
#include "include/raylib.h"
#include "include/raymath.h"

// Function to get a random element from an unordered_set
template <typename T>
const T& getRandomElement(const std::unordered_set<T>& s);

// Function to get the last element from an unordered_set
template <typename T>
const T& getLastElement(const std::unordered_set<T>& s);

namespace std {
    // Specialize the std::hash struct for raylib's Vector2 type
    template <>
    struct hash<Vector2> {
        // The operator() takes a const reference to the type and returns a size_t hash value
        size_t operator()(const Vector2& vec) const {
            // Get the standard hash values for the component types (int)
            size_t h1 = std::hash<int>{}(vec.x);
            size_t h2 = std::hash<int>{}(vec.y);

            // A simple and effective way to combine two hash values:
            // XOR the first hash with the second hash left-shifted by 1 bit.
            // This ensures both components contribute to the final hash.
            return h1 ^ (h2 << 1);            
        }
    };
}

/*
TODO: 
01. Make a map tile struct with the following properties:
    - bool explored
    - bool passable
    - bool opaque
    - std::string id
    - std::string tile
    - Vector2 position
    - Color color

*/


/*enum MapTileType {
    DARKNESS,
    GROUND,
    WALL,
    FLOOR,
    DOOR,
    STAIRS_UP,
    STAIRS_DOWN    
};*/

/*struct Tile {
    MapTileType id;
    std::string tile;
};*/

/*class MapTile: public Entity {
    public:
    MapTileType id;
    MapTile(int x, int y, MapTileType id, std::string tile, Color color);
};*/

class Map {
    public:
    Vector2 start_position;
    int iterations;
    int walk_length;
    bool start_randomly_each_iteration;
    int corridor_length;
    int corridor_count;
    float room_percent;
    
    //std::vector<Tile> tileset;
    std::vector<MapTile> tiles;
    
    void create_corridors(std::unordered_set<Vector2> floor_positions);
    std::unordered_set<Vector2> run_random_walk();
    std::unordered_set<Vector2> simple_random_walk(Vector2 start_position, int walk_length);
    std::vector<Vector2> direction2d();
    Vector2 get_random_cardinal_direction(std::vector<Vector2> directions);
    void create_walls(std::unordered_set<Vector2> floor_positions);
    std::unordered_set<Vector2> find_walls_in_directions(std::unordered_set<Vector2> floor_positions);
    std::unordered_set<Vector2> random_walk_corridor(Vector2 start_position, int corridor_length);
    Map();
    void Generate(int width, int height, Vector2 start_position);

    ~Map();
};